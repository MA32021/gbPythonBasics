# 3. Реализовать программу работы с органическими клетками,
# состоящими из ячеек. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр,
# соответствующий количеству ячеек клетки # (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:

# сложение (__add__()),
# вычитание (__sub__()),
# умножение (__mul__()),
# деление (__truediv__()).
#
# Данные методы должны применяться только к клеткам и выполнять увеличение,
# уменьшение, умножение и целочисленное (с округлением до целого) деление клеток,
# соответственно.
#
# Сложение.
# Объединение двух клеток.
# При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.

# Вычитание. Участвуют две клетки.
# Операцию необходимо выполнять только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение.

# Умножение. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как произведение
# количества ячеек этих двух клеток.

# Деление. Создаётся общая клетка из двух.
# Число ячеек общей клетки определяется как целочисленное деление
# количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(),
# принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
#
# Метод должен возвращать строку вида *****\n*****\n*****...,
# где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает,
# то в последний ряд записываются все оставшиеся.
#
# Например, количество ячеек клетки равняется 12,
# количество ячеек в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернёт строку: *****\n*****\n*****.

class Cell:
    def __init__(self, size):
        self.size = size
        # order для вывода на печать по умолчанию равен 4
        self.order = 4

    def __add__(self, other):
        return Cell(self.size + other.size)

    def __sub__(self, other):
        if self.size - other.size <= 0:
            print('Резульатат вычитания клеток не может быть <= 0!')
            return self
        else:
            return Cell(self.size - other.size)

    def __mul__(self, other):
        return Cell(self.size * other.size)

    def __truediv__(self, other):
        """
        по условию задачи результат - это целочисленное деление,
        то есть получившаяся клетка может оказаться нулевой,
        что нелогично, так как при вычитании результат не может быть 0!
        Но оставляем как в задании...
        """
        return Cell(self.size // other.size)

    def make_order(self, length):
        # хотя в задании не указано, но предусмотрим вывод и для нулевой клетки
        if length <= 0 or self.size == 0:
            return '<Пустая клетка>'
        # пусть метод make_order() меняет аттрибут order объекта
        self.order = length
        if length >= self.size:
            line = '*' * self.size + '\n'
        else:
            line = ''
            for i in range(length, self.size + 1, length):
                line += '*' * length + '\n'
            line += '*' * (self.size % length) + '\n' if self.size % length is not 0 else ''
        return line[:len(line) - 1]

    def __str__(self):
        return self.make_order(self.order)


a10 = Cell(10)
print(f'a10:\n{a10}')
a20 = Cell(20)
print(f'a20:\n{a20}')
a = a10 + a20
print(f'a10+a20:\n{a}')
a.make_order(10)
print(f'a10+a20 по 10:\n{a}')
a4 = Cell(4)
print(f'a4:\n{a4}')
a5 = Cell(5)
print(f'a5:\n{a5}')
a = a5 - a4
print(f'a5-a4:\n{a}')
a6 = Cell(6)
print(f'a6:\n{a6}')
a7 = Cell(7)
print(f'a7:\n{a7}')
a = a7 / a6
print(f'a7/a6:\n{a}')
a = a6 / a7
print(f'a6/a7:\n{a}')
a = a4 * a5
a.make_order(8)
print(f'a4*a5 по 8:\n{a}')
